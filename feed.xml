<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://qhe-ai.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://qhe-ai.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-07T20:41:33+00:00</updated><id>https://qhe-ai.github.io/feed.xml</id><title type="html">Qiang HE</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">A quick reference manual for pandas and seaborn</title><link href="https://qhe-ai.github.io/blog/2022/pandas_seaborn/" rel="alternate" type="text/html" title="A quick reference manual for pandas and seaborn"/><published>2022-07-20T08:00:00+00:00</published><updated>2022-07-20T08:00:00+00:00</updated><id>https://qhe-ai.github.io/blog/2022/pandas_seaborn</id><content type="html" xml:base="https://qhe-ai.github.io/blog/2022/pandas_seaborn/"><![CDATA[<h1 id="seaborn-pandas-速查手册">Seaborn Pandas 速查手册</h1> <p>这篇笔记是作为速查来使用的，读者无需仔细阅读，了解原理</p> <h2 id="获取表头">获取表头</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data.columns

Index(['beta', 'alien', 'bank_heist', 'freeway', 'frostbite', 'jamesbond',
       'kangaroo', 'ms_pacman'],
      dtype='object')
</code></pre></div></div> <h2 id="设置刻度字体-图例字体-大小-图例标题有无">设置刻度字体 图例字体 大小 图例标题有无</h2> <p>https://zhuanlan.zhihu.com/p/437747308</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ax = sns.scatterplot(x='账单', y='小费', hue='性别', data=tips)
x = [-40, -20, 0, 20, 40]
ax.set_xticks(x)
xlabs = [-40, -20, 0, 20, 40]
ax.set_xticklabels(xlabs, fontsize=14) #设置X座标轴刻度标签字体
y = [0, 2, 4, 6, 8, 10]
ax.set_yticks(y)
ylabs = [0, 2, 4, 6, 8, 10]
ax.set_yticklabels(ylabs, fontsize=14, rotation=30) #设置Y座标轴刻度标签字体
ax.set_ylabel('小费', fontsize=14) #设置Y坐标轴标签字体
ax.set_xlabel('账单', fontsize=14) #设置X坐标轴标签字体
ax.set_title('简单示例图', fontsize=14) #设置标题字体
ax.legend(title = "性别", fontsize = 12, title_fontsize = 14) #设置图例标题、图例标题字体大小、图例字体大小
</code></pre></div></div> <p><strong>关于图例</strong></p> <p>https://stackoverflow.com/questions/51579215/remove-seaborn-lineplot-legend-title</p> <p>使用以下的方法可以去掉图例的标题，设置图例大小</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>handles, labels = ax.get_legend_handles_labels()
ax.legend(handles=handles[1:], labels=labels[1:])
plt.setp(ax.get_legend().get_texts(), fontsize=20)
</code></pre></div></div> <h2 id="控制坐标轴-刻度-标签-是否可见-旋转-自动调整">控制坐标轴 刻度 标签 是否可见 旋转 自动调整</h2> <p>关闭某个子图坐标轴，不可见框线</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">set_axis_off</span><span class="p">()</span>
</code></pre></div></div> <p>关闭刻度，可见框线</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">get_xaxis</span><span class="p">().</span><span class="nf">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">get_yaxis</span><span class="p">().</span><span class="nf">set_visible</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div> <p>关闭标签</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ax.set(xlabel=None)
ax.set(ylabel=None)
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fig.autofmt_xdate()
fig.yticks(y_tick,fontsize=20)
fig.autofmt_ydate()
</code></pre></div></div> <h2 id="plt-的画线风格">plt 的画线风格</h2> <p>https://blog.csdn.net/qq_34940959/article/details/78488208</p> <p>颜色（color 简写为 c）：</p> <p>蓝色： ‘b’ (blue) 绿色： ‘g’ (green) 红色： ‘r’ (red) 蓝绿色(墨绿色)： ‘c’ (cyan) 红紫色(洋红)： ‘m’ (magenta) 黄色： ‘y’ (yellow) 黑色： ‘k’ (black) 白色： ‘w’ (white) 灰度表示： e.g. 0.75 ([0,1]内任意浮点数) RGB表示法： e.g. ‘#2F4F4F’ 或 (0.18, 0.31, 0.31) 任意合法的html中的颜色表示： e.g. ‘red’, ‘darkslategray’ 线型（linestyle 简写为 ls）：</p> <p>实线： ‘-‘ 虚线： ‘–’ 虚点线： ‘-.’ 点线： ‘:’ 点： ‘.’ 点型（标记marker）：</p> <p>像素： ‘,’ 圆形： ‘o’ 上三角： ‘^’ 下三角： ‘v’ 左三角： ‘&lt;’ 右三角： ‘&gt;’ 方形： ‘s’ 加号： ‘+’ 叉形： ‘x’ 棱形： ‘D’ 细棱形： ‘d’ 三脚架朝下： ‘1’（就是丫） 三脚架朝上： ‘2’ 三脚架朝左： ‘3’ 三脚架朝右： ‘4’ 六角形： ‘h’ 旋转六角形： ‘H’ 五角形： ‘p’ 垂直线： ‘|’ 水平线： ‘_’ gnuplot 中的steps： ‘steps’ （只能用于kwarg中） 标记大小（markersize 简写为 ms）：</p> <p>markersize： 实数 标记边缘宽度（markeredgewidth 简写为 mew）：</p> <p>markeredgewidth：实数 标记边缘颜色（markeredgecolor 简写为 mec）：</p> <p>markeredgecolor：颜色选项中的任意值 标记表面颜色（markerfacecolor 简写为 mfc）：</p> <p>markerfacecolor：颜色选项中的任意值 透明度（alpha）：</p> <p>alpha： [0,1]之间的浮点数 线宽（linewidth）：</p> <p>linewidth： 实数</p> <h2 id="调色系统">调色系统</h2> <p>http://seaborn.pydata.org/tutorial/color_palettes.html?highlight=palette%20rocket</p>]]></content><author><name></name></author><category term="blog"/><category term="RL,"/><category term="Programming"/><summary type="html"><![CDATA[Seaborn Pandas 速查手册]]></summary></entry><entry><title type="html">Displaying External Posts on Your al-folio Blog</title><link href="https://qhe-ai.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/" rel="alternate" type="text/html" title="Displaying External Posts on Your al-folio Blog"/><published>2022-04-23T23:20:09+00:00</published><updated>2022-04-23T23:20:09+00:00</updated><id>https://qhe-ai.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog</id><content type="html" xml:base="https://qhe-ai.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">An introduction to Docker for deep learning researcher</title><link href="https://qhe-ai.github.io/blog/2022/docker/" rel="alternate" type="text/html" title="An introduction to Docker for deep learning researcher"/><published>2022-04-20T08:00:00+00:00</published><updated>2022-04-20T08:00:00+00:00</updated><id>https://qhe-ai.github.io/blog/2022/docker</id><content type="html" xml:base="https://qhe-ai.github.io/blog/2022/docker/"><![CDATA[<h1 id="docker-极简教程">Docker 极简教程</h1> <font color="red">作者不对文章内容以及文章内容使用不当引发的任何后果负任何责任。请谨慎敲下每一个命令。</font> <p>本文档的目的是帮助深度学习新手一个小时内快速上手docker。</p> <h1 id="预备知识">预备知识</h1> <p>本文档假定读者具有基本的docker知识, 一些Ubuntu操作经验, 基本的git操作基础. 如果你遇到问题,请首先通过搜索引擎尝试寻找解决方案. 后面再求助能够帮助你的人.</p> <p><a href="https://www.runoob.com/git/git-branch.html">git工具的简单使用</a></p> <h1 id="安装">安装</h1> <p>不同平台的安装方式请查看Docker官方文档 (https://docs.docker.com/engine/install/).</p> <p>这里以Ubuntu系统为例子</p> <h2 id="安装docker-文件">安装Docker 文件</h2> <p>首先添加源:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="se">\</span>
    apt-transport-https <span class="se">\</span>
    ca-certificates <span class="se">\</span>
    curl <span class="se">\</span>
    gnupg-agent <span class="se">\</span>
    software-properties-common
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
</code></pre></div></div> <p>然后安装docker</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli 
</code></pre></div></div> <p>接下来检测是否正常安装.</p> <p>输入</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker run hello-world
</code></pre></div></div> <p>然后显示</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unable to find image <span class="s1">'hello-world:latest'</span> locally

latest: Pulling from library/hello-world
2db29710123e: Pull <span class="nb">complete 
</span>Digest: sha256:97a379f4f88575512824f3b352bc03cd75e239179eea0fecc38e597b2209f49a
Status: Downloaded newer image <span class="k">for </span>hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the <span class="s2">"hello-world"</span> image from the Docker Hub.
    <span class="o">(</span>amd64<span class="o">)</span>
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 <span class="nv">$ </span>docker run <span class="nt">-it</span> ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre></div></div> <h2 id="centos-安装docker">Centos 安装docker</h2> <p><a href="https://www.lmf.life/archives/centos7%E5%AE%89%E8%A3%85nvidia-docker2">参考</a></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo /bin/yum update
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo /bin/yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre></div></div> <p>设置源</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum -y install yum-utils
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo yum list docker-ce --showduplicates | sort -r
</code></pre></div></div> <p>然后选择安装</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum install docker-ce
</code></pre></div></div> <p>接下来安装nvidia-docker</p> <p>首先配置</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \
   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.repo | sudo tee /etc/yum.repos.d/nvidia-docker.repo
</code></pre></div></div> <p>更新</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo yum clean expire-cache
</code></pre></div></div> <p>安装</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo yum install -y nvidia-docker2
</code></pre></div></div> <p>通过测试</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker -v
</code></pre></div></div> <p>centos上的一些小命令</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df -Th /var/lib/docker
df -h
</code></pre></div></div> <p>第一个命令查看目标目录使用情况</p> <p>第二个命令查看整体情况</p> <h2 id="安装nvidia-docker">安装nvidia docker</h2> <p>为了调用显卡, 我们还需要安装nvidia docker, 请参考<a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker">官方文档</a>进行安装.</p> <p>下面我们以Ubuntu 平台为例.</p> <p>设置docker</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl https://get.docker.com | sh \
  &amp;&amp; sudo systemctl --now enable docker
</code></pre></div></div> <p>设置nvidia 容器工具</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \
   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \
   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list
</code></pre></div></div> <p>安装</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get update
sudo apt-get install -y nvidia-docker2
</code></pre></div></div> <p>重启</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo systemctl restart docker
</code></pre></div></div> <p>然后检查一下是不是可用</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi
</code></pre></div></div> <p>如果显示,</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Mon Feb 28 01:46:31 2022       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 470.103.01   Driver Version: 470.103.01   CUDA Version: 11.4     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|<span class="o">===============================</span>+<span class="o">======================</span>+<span class="o">======================</span>|
|   0  NVIDIA GeForce ...  Off  | 00000000:01:00.0  On |                  N/A |
| 46%   44C    P0    49W / 180W |    803MiB /  8119MiB |      1%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|<span class="o">=============================================================================</span>|
+-----------------------------------------------------------------------------+

</code></pre></div></div> <p>那么就搞定了.</p> <h2 id="离线安装docker">离线安装docker</h2> <p>在<a href="https://download.docker.com/linux/static/stable/x86_64/">这里</a>可以下载离线的docker文件.</p> <p>找到存放有<code class="language-plaintext highlighter-rouge">docker-20.10.9.tgz</code>的文件夹. 注意你可能需要sudo权限.</p> <p>首先解压</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -xzvf docker-20.10.9.tgz
</code></pre></div></div> <p>之后进入docker目录, 并且将所有文件拷贝到<code class="language-plaintext highlighter-rouge">/usr/bin/</code>目录下</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd docker/
cp * /usr/bin/
</code></pre></div></div> <p>将如下内容写入<code class="language-plaintext highlighter-rouge">/etc/systemd/system/docker.service</code></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/systemd/system/docker.service
</code></pre></div></div> <p>然后在弹出来的页面写入</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target

[Service]
Type=notify
ExecStart=/usr/bin/dockerd
ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=infinity
LimitNPROC=infinity
TimeoutStartSec=0
Delegate=yes
KillMode=process
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s

[Install]
WantedBy=multi-user.target

</code></pre></div></div> <p>给刚才写入的文件增加权限</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod +x /etc/systemd/system/docker.service
systemctl daemon-reload 
</code></pre></div></div> <p>设置开启启动docker</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl enable docker.service
</code></pre></div></div> <p>然后启动docker</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl start docker
</code></pre></div></div> <p>然后通过以下方式检查docker是否安装</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker -v
</code></pre></div></div> <p>如果弹出</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Docker version 20.10.9, build c2ea9bc
</code></pre></div></div> <p>那么说明安装成功.</p> <h2 id="离线安装nvidia-docker">离线安装nvidia docker</h2> <p>想在Docker中用GPU资源，就需要安装NVIDIA Container Toolkit，如果工作站能连外网，按照官网的步骤很容易安装，但如果不能连外网，比如只能在校园网IP范围内使用，该如何安装呢？</p> <blockquote> <p>预设条件：已经安装好了显卡驱动和Docker 以下所有下载任务选择最新版；</p> </blockquote> <p>Step 1. 下载<code class="language-plaintext highlighter-rouge">libnvidia-container</code> 安装包（在Ubuntu下是deb文件）</p> <p><a href="https://link.zhihu.com/?target=https%3A//github.com/NVIDIA/libnvidia-container/tree/gh-pages/stable">libnvidia-container/stable at gh-pages · NVIDIA/libnvidia-container (github.com)github.com/NVIDIA/libnvidia-container/tree/gh-pages/stable</a></p> <p>通过VPN传到工作站上，运行</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dpkg <span class="nt">-i</span> libnvidia-container1_1.4.0-1_amd64.deb
</code></pre></div></div> <p>然后下载安装libnvidia-container-tools</p> <p>https://github.com/NVIDIA/libnvidia-container/tree/gh-pages/stable</p> <p>Step 2. 下载<code class="language-plaintext highlighter-rouge">nvidia-container-toolkit</code> 和 <code class="language-plaintext highlighter-rouge">nvidia-container-runtime</code></p> <p><a href="https://link.zhihu.com/?target=https%3A//github.com/NVIDIA/nvidia-container-runtime/tree/gh-pages/stable">nvidia-container-runtime/stable at gh-pages · NVIDIA/nvidia-container-runtime (github.com)github.com/NVIDIA/nvidia-container-runtime/tree/gh-pages/stable</a></p> <p>以Ubuntu 18.04 为例，分别运行</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo dpkg -i nvidia-container-toolkit_1.5.1-1_amd64.deb
sudo dpkg -i nvidia-container-runtime_3.5.0-1_amd64.deb
</code></pre></div></div> <p>Step 3. 下载<code class="language-plaintext highlighter-rouge">nvidia-docker2</code> 并上传到工作站、安装</p> <p><a href="https://link.zhihu.com/?target=https%3A//github.com/NVIDIA/nvidia-docker/tree/gh-pages">NVIDIA/nvidia-docker at gh-pages (github.com)github.com/NVIDIA/nvidia-docker/tree/gh-pages</a></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dpkg <span class="nt">-i</span> nvidia-docker2_2.6.0-1_all.deb
</code></pre></div></div> <p>Step 4. 重启Docker</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>service docker restart
</code></pre></div></div> <h2 id="为非root用户配置docker-使用权限">为非root用户配置docker 使用权限</h2> <ol> <li>使用root用户登录</li> <li>新建用户组docker之前，查看用户组中有没有docker组</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo cat /etc/group | grep docker
</code></pre></div></div> <ol> <li>创建docker分组，并将相应的用户添加到这个分组里面</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo groupadd -g 999 docker 
sudo usermod -aG docker quyuxun
</code></pre></div></div> <ol> <li>检查一下创建是否有效</li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /etc/group
</code></pre></div></div> <ol> <li> <p>退出当前登录用户，或者重启docker，以让docker用户组生效</p> </li> <li> <p>确认可以使用docker</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker ps -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</code></pre></div> </div> </li> </ol> <p>如果提示get ……dial unix /var/run/docker.sock权限不够，则修改/var/run/docker.sock权限</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo chmod a+rw /var/run/docker.sock
</code></pre></div></div> <h1 id="配置baseline的docker">配置baseline的docker</h1> <p>baseline 是openai开发的代码库，用来搞强化学习，没有需求的同学可以跳过。</p> <h2 id="baseline的安装">baseline的安装</h2> <p>注意baseline需要有prerequisite</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get update &amp;&amp; sudo apt-get install cmake libopenmpi-dev python3-dev zlib1g-dev
</code></pre></div></div> <p>然后下载baselines</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/openai/baselines.git
cd baselines
</code></pre></div></div> <p>然后安装tensorflow-gpu</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install tensorflow-gpu
</code></pre></div></div> <p>切换到tf2分支(如果愿意,也可以使用tf1), 并且安装</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout tf2
pip install -e .
</code></pre></div></div> <p>然后使用如下代码进行测试</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python -m baselines.run --alg=ppo2 --env=PongNoFrameskip-v4 --num_timesteps=0 --load_path=~/models/pong_20M_ppo2 --play
</code></pre></div></div> <p>这个时候, 你会看到一个gui界面, 那么就成功了.</p> <p><img src="/home/mirror/.config/Typora/typora-user-images/image-20220228112924661.png" alt="image-20220228112924661"/></p> <p>然后开始制作docker镜像</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker build -t docker_sample:latest .
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker build -t tl_rl:0.1 .
</code></pre></div></div> <p>这里的 <code class="language-plaintext highlighter-rouge">.</code> 是目录, docker_sample是镜像名字, latest是版本号, 可以用<code class="language-plaintext highlighter-rouge">0.1</code>等标记.</p> <p>然后导出docker镜像</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker save -o docker_image_name.tar docker_sample:latest
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> sudo docker save -o tf_rl.tar tl_rl:0.1
</code></pre></div></div> <p>注意, 导出的镜像可能由于所有者权限问题, 而无法被移动或者复制, 这时候我们需要修改文件权限</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo chmod 777 docker_image_name.tar
</code></pre></div></div> <h1 id="docker-镜像的使用">Docker 镜像的使用</h1> <h2 id="使用压缩好的docker">使用压缩好的docker</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker load -i rl_tf.tar 
sudo docker load --input rl_tf.tar
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11936051f93b: Loading layer [==================================================&gt;]  129.1MB/129.1MB
...
f63153c62cad: Loading layer [==================================================&gt;]  2.179GB/2.179GB
Loaded image: rl_tf:0.1
</code></pre></div></div> <p>然后我们<code class="language-plaintext highlighter-rouge">sudo docker images</code>可以看到</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REPOSITORY   TAG       IMAGE ID       CREATED             SIZE
rl_tf        0.1       e5e284047d3f   About an hour ago   3.48GB
</code></pre></div></div> <p>注意, 我们将这个image ID复制下来, 然后</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker run -it --rm e5e284047d3f /bin/bash
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker run --gpus all -it --rm fe7dab327f77 /bin/bash
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python -m baselines.run --alg=ppo2 --env=MountainCar-v0
CUDA_VISIBLE_DEVICES=4 python train.py
</code></pre></div></div> <p>接下来我们就进入了docker 容器了</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@8dc4fac45394:~/code/baselines# 
</code></pre></div></div> <p><a href="https://blog.csdn.net/liujiaping/article/details/121957529">使用带用户的docker命令</a></p> <p>查看uid</p> <p>id</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uid=1009(quyuxun) gid=1009(quyuxun) groups=1009(quyuxun)
</code></pre></div></div> <p>可以看到此时的uid为1009</p> <p>然后</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -it --user=1009 --gpus=all ed62683294a2 /bin/bash
</code></pre></div></div> <p>显示</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>------------------------------------------
| eplenmean               | 200          |
| eprewmean               | -200         |
| fps                     | 1093         |
| loss/approxkl           | 8.478222e-05 |
| loss/clipfrac           | 0.0          |
| loss/policy_entropy     | 1.0985302    |
| loss/policy_loss        | -0.000300169 |
| loss/value_loss         | 121.43289    |
| misc/explained_variance | -0.000372    |
| misc/nupdates           | 1            |
| misc/serial_timesteps   | 2048         |
| misc/time_elapsed       | 1.87         |
| misc/total_timesteps    | 2048         |
------------------------------------------
</code></pre></div></div> <h2 id="拉取docker-image">拉取Docker image</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker pull davidfitzek/stable-baselines3-gpu:0.4
</code></pre></div></div> <p>然后就开始拉取了</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(baseline) mirror@mirror:~/Documents/code/Baseline_Docker/baselines/baselines$ sudo docker pull davidfitzek/stable-baselines3-gpu:0.4
0.4: Pulling from davidfitzek/stable-baselines3-gpu
...
Digest: sha256:5b3f1606b747b1ea9dabc23b8c4970e5141845e89b9df9a4ea9f013128e1bcdf
Status: Downloaded newer image for davidfitzek/stable-baselines3-gpu:0.4
docker.io/davidfitzek/stable-baselines3-gpu:0.4
</code></pre></div></div> <p>然后开始运行docker</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker run -it --rm davidfitzek/stable-baselines3-gpu:0.4
</code></pre></div></div> <p>使用如下脚本测试</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">stable_baselines3</span> <span class="kn">import</span> <span class="n">PPO</span>

<span class="n">model</span> <span class="o">=</span> <span class="nc">PPO</span><span class="p">(</span><span class="sh">'</span><span class="s">MlpPolicy</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">CartPole-v1</span><span class="sh">'</span><span class="p">).</span><span class="nf">learn</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
</code></pre></div></div> <h2 id="安装rom">安装ROM</h2> <p>为了让你的电脑能够运行atari游戏,你需要安装atari的rom</p> <p>进入: https://github.com/openai/atari-py#roms</p> <p>然后解压到一个位置, 接下来安装</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python -m atari_py.import_roms &lt;path to folder&gt;
</code></pre></div></div> <p>注意, 安装之后就不要移动rom的位置了, 否则会造成运行出问题.</p> <p>如果这个脚本无法成功运行, 也可以将文件手动拷贝到你的atari_roms目录下</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/anaconda3/envs/baseline/lib/python3.6/site-packages/atari_py/atari_roms
</code></pre></div></div> <h3 id="使用ale环境安装atari">使用ALE环境安装atari</h3> <p>如果你无法使用atari-py安装rom, 那么请你使用ALE环境</p> <p>https://github.com/mgbellemare/Arcade-Learning-Environment</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install ale-py
ale-import-roms roms/
</code></pre></div></div> <h2 id="将anaconda环境迁移到docker中">将anaconda环境迁移到docker中</h2> <p><a href="https://blog.csdn.net/qq_43787006/article/details/114368252">此处参考</a></p> <p>首先搜索anaconda镜像</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker search anaconda
</code></pre></div></div> <p>然后拉取镜像</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull anaconda
</code></pre></div></div> <p>然后运行镜像</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker run -i -t continuumio/anaconda3 /bin/bash
sudo docker run --gpus all -it --rm continuumio/anaconda3 /bin/bash

# sudo docker run -i -t continuumio/anaconda3 /bin/bash 909fa31992e8
# sudo docker run --gpus all nvidia/cuda:10.1 curl
</code></pre></div></div> <p>docker环境下，查找anaconda路径</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whereis anaconda
</code></pre></div></div> <p>本地环境下 复制本地环境到docker</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker cp your_path/anaconda3/envs/env_name docker_name:anaconda_path/envs
# sudo docker cp /home/mirror/anaconda3/envs/rprl 909fa31992e8:.
</code></pre></div></div> <p>这里要注意，首先我们要选择dockerID进行复制，这个ID通过<code class="language-plaintext highlighter-rouge">docker ps -a</code>查看，然后选择对应的ID。</p> <p>之后我们使用</p> <p>将docker容器保存为镜像</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker commit -a [author] -m [instruction] docker_name image_name
sudo docker commit -a heqiang -m 909fa31992e8 curl

$ sudo docker commit -m "Add curl code" -a "heqiang" 4ece334a2d32 curl:latest
4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c
</code></pre></div></div> <p>其中，-m 来指定提交的说明信息，跟我们使用的版本控制工具一样；-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID 信息。</p> <p>查看新镜像</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker image ls
</code></pre></div></div> <p>将镜像保存为压缩包</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker save image_name -o compressed_package_name.tar
</code></pre></div></div> <p>docker镜像导入 在新的机器上导入之前创建的docekr环境。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker load -i compressed_package_name
</code></pre></div></div> <p>启动docker镜像</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -i -t docker_image_name /bin/bash
</code></pre></div></div> <h1 id="docker-数据存储">Docker 数据存储</h1> <p><a href="https://blog.51cto.com/u_15358844/3792845">参考文章</a></p> <h2 id="什么是数据卷">什么是数据卷</h2> <p>​ 我们都知道在Docker中，容器的数据读写默认发生在容器的存储层，当容器被删除时其上的数据将会丢失。如果想实现数据的持久化，就需要将容器和宿主机建立联系（将数据从宿主机挂载到容器内），通俗的说，数据卷就是在容器和宿主机之间实现数据共享。</p> <h2 id="docker支持的三种数据挂载方式">Docker支持的三种数据挂载方式</h2> <p>Docker提供了三种不同的方式将数据从宿主机挂载到容器中：volume、bind mounts、tmpfs mounts</p> <p>volume：Docker管理宿主机文件系统的一部分（/var/lib/docker/volumes）</p> <p>bind mounts：可以存储在宿主机系统的任意位置</p> <h2 id="使用绑定数据卷存储数据">使用绑定数据卷存储数据</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -it --mount type=bind,source=/opt,target=/root/code/curl/curl_data/ curl /bin/bash
</code></pre></div></div> <p>这样就完成了目录的映射，然后将数据存储在对应的目录上就好了，即使是退出docker，也能保存docker产生的数据。</p> <h2 id="tmpfs-mounts挂载存储在宿主机系统的内存中不会写入宿主机的文件系统">tmpfs mounts：挂载存储在宿主机系统的内存中，不会写入宿主机的文件系统</h2> <p>©著作权归作者所有：来自51CTO博客作者qq6136ff484095f的原创作品，请联系作者获取转载授权，否则将追究法律责任 Docker数据存储方式：数据卷（Data Volume） https://blog.51cto.com/u_15358844/3792845</p> <h1 id="使用技巧">使用技巧</h1> <h2 id="30系显卡的使用">30系显卡的使用</h2> <p>30系的显卡，需要对的cuda 的torch版本</p> <p>使用这种方法来安装torch版本就好了，这个请在Dockerfile里完成。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu113
</code></pre></div></div> <h2 id="基本技巧">基本技巧</h2> <p>如下是常用docker 命令.</p> <p>制作docker</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker build -t popro:latest .
</code></pre></div></div> <p>制作docker文件</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker save image_name -o compressed_package_name
</code></pre></div></div> <p>删除容器</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">rm </span>CONTAINER_ID
</code></pre></div></div> <p>列出所有容器（包括正在运行的和已经退出的容器）</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker ps -a
</code></pre></div></div> <p>停止正在运行的容器</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker stop CONTAINER_ID
</code></pre></div></div> <p>删除镜像（删除镜像之前需要删除所有该镜像下的容器）</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker rmi IMAGE_ID
</code></pre></div></div> <p>重命名</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker tag 0d5b39aeafc2 rprl:1.0
</code></pre></div></div> <p>导出docker镜像</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker save -o docker_image_name.tar docker_sample:latest
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker save -o tf_rl.tar tl_rl:0.1
</code></pre></div></div> <p>注意, 导出的镜像可能由于所有者权限问题, 而无法被移动或者复制, 这时候我们需要修改文件权限</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo chmod 777 docker_image_name.tar
</code></pre></div></div> <p>将docker容器保存为镜像</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker commit -a [author] -m [instruction] docker_name image_name
sudo docker commit -a heqiang -m 909fa31992e8 curl

$ sudo docker commit -m "Add curl code" -a "heqiang" 4ece334a2d32 curl:latest
4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c
</code></pre></div></div> <p>其中，-m 来指定提交的说明信息，跟我们使用的版本控制工具一样；-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID 信息。</p> <p>查看新镜像</p> <p>docker run启动一个docker之后，就会生成一个容器，然后这个容器就会一直存在系统里，因此不用再使用docker run启动新的容器了。</p> <p>所以目前再找到之前保存的docker logs，然后找到ID，启动就好了</p> <p>寻找docker ID</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker ps -a
</code></pre></div></div> <p>寻找该docker 下发生了啥</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker logs docker_Id	
</code></pre></div></div> <p>然后启动该docker</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker start docker_id
</code></pre></div></div> <p>之后再attach上docker就好了</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker attach docker_name
</code></pre></div></div> <p>清理整个docker 系统</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker system prune
</code></pre></div></div> <h2 id="写dockerfile的时候">写dockerfile的时候</h2> <p>FROM不需要注明版本号，例如</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM continuumio/anaconda3
</code></pre></div></div> <p>记得要写-y</p> <h2 id="docker-layer的逻辑">docker layer的逻辑</h2> <p>docker 会对每一次run，都生成一次layer，所以我们可以将一堆shell脚本，打包在一起，例如 <code class="language-plaintext highlighter-rouge">docker.sh</code></p> <p>然后，我们输入如下语句，就可以了</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>COPY docker.sh .
RUN chmod +x docker.sh
RUN ./docker.sh
</code></pre></div></div> <h2 id="普通用户使用docker">普通用户使用docker</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo groupadd docker
sudo gpasswd -a ${USER} docker
sudo systemctl restart docker
</code></pre></div></div> <h1 id="bug-排除">BUG 排除</h1> <p>这里提供一些bug的排除机制</p> <h2 id="importerror-cannot-import-name-flattendictwrapper">ImportError: cannot import name ‘FlattenDictWrapper’</h2> <p>这是由于<a href="https://github.com/openai/baselines/issues/1129">gym环境的支持问题</a>, 使用baseline的tf2分支, 请使用gym==0.14</p> <p>解决:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install gym==0.14
</code></pre></div></div> <h2 id="error-response-from-daemon-could-not-select-device-driver--with-capabilities-gpu">Error response from daemon: could not select device driver ““ with capabilities: [[gpu]]</h2> <p>安装nvidia-docker就可以解决。<a href="https://blog.csdn.net/dou3516/article/details/108314908">见</a></p> <p><a href="https://zhuanlan.zhihu.com/p/397638816">安装的方法</a></p> <h2 id="终端设置代理">终端设置代理</h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export http_proxy=http://127.0.0.1:12333
</code></pre></div></div> <h2 id="mujoco-distutilserrorscompileerror-command-gcc-failed-with-exit-status-1">MuJoCo: distutils.errors.CompileError: command ‘gcc’ failed with exit status 1</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install libosmesa6-dev libgl1-mesa-glx libglfw3
sudo apt-get install patchelf
</code></pre></div></div> <p>sudo apt install libosmesa6-dev</p>]]></content><author><name></name></author><category term="blog"/><category term="RL,"/><category term="Programming"/><summary type="html"><![CDATA[Docker 极简教程]]></summary></entry><entry><title type="html">Common skills of ubuntu</title><link href="https://qhe-ai.github.io/blog/2019/Config_static_ipv6/" rel="alternate" type="text/html" title="Common skills of ubuntu"/><published>2019-12-25T08:00:00+00:00</published><updated>2019-12-25T08:00:00+00:00</updated><id>https://qhe-ai.github.io/blog/2019/Config_static_ipv6</id><content type="html" xml:base="https://qhe-ai.github.io/blog/2019/Config_static_ipv6/"><![CDATA[<h2 id="配置静态ipv6地址">配置静态ipv6地址</h2> <p>首先进入编辑界面</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /etc/network/interfaces
</code></pre></div></div> <p>再添加</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iface eth0 inet6 static
</code></pre></div></div> <h2 id="配置新用户">配置新用户</h2> <p>这里推荐这种方式</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>useradd -d /home/user_name -m user_name
</code></pre></div></div> <p>在home/下创建一个user_name 目录</p> <p>之后再配置密码</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>passwd user_name
</code></pre></div></div> <p>为该用户指定命令解释程序（通常为/bin/bash）</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>usermod -s /bin/bash user_name
</code></pre></div></div> <p>删除账号</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>userdel -r user_name
</code></pre></div></div> <p>-r 参数为删除该目录下所有的文件</p> <h2 id="ssh-相关服务">SSH 相关服务</h2> <h3 id="指定ssh端口映射">指定ssh端口映射:</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh -L 6006:localhost:6006 username@ip
</code></pre></div></div> <h3 id="杀死占用某个端口的程序">杀死占用某个端口的程序：</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fuser 6006/tcp -k
</code></pre></div></div> <h3 id="快捷ssh命令访问服务器">快捷ssh命令访问服务器</h3> <ul> <li>生成ssh 公钥 <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-keygen
</code></pre></div> </div> </li> <li>上传到服务器 <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp -r ~/.ssh/id_rsa.pub  mirror@170.18.40.99:~/
</code></pre></div> </div> </li> <li>写入 <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre></div> </div> </li> <li>在本地处理 <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim ~/.ssh/config
</code></pre></div> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host alians
  HostName dev.example.com
  Port 22
  User fooey
</code></pre></div> </div> </li> <li>修改文件权限 <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo chmod 600 .ssh/config 
</code></pre></div> </div> </li> </ul> <p><a href="https://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/">参考</a></p> <h2 id="限定服务器python程序数量">限定服务器python程序数量</h2> <p>原理是替换掉python程序启动方式</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alias python='run-one python'
</code></pre></div></div>]]></content><author><name></name></author><category term="blog"/><category term="RL,"/><category term="Programming"/><summary type="html"><![CDATA[配置静态ipv6地址]]></summary></entry><entry><title type="html">Functional Gradient Descent</title><link href="https://qhe-ai.github.io/blog/2019/functional_gradient_descent/" rel="alternate" type="text/html" title="Functional Gradient Descent"/><published>2019-12-25T08:00:00+00:00</published><updated>2019-12-25T08:00:00+00:00</updated><id>https://qhe-ai.github.io/blog/2019/functional_gradient_descent</id><content type="html" xml:base="https://qhe-ai.github.io/blog/2019/functional_gradient_descent/"><![CDATA[<p>Claim: This is a backup of <a href="https://simple-complexities.github.io/optimization/functional/gradient/descent/2020/03/04/functional-gradient-descent.html">this post</a>!</p> <p>The content in this post has been adapted from <a href="http://www.cs.cmu.edu/~16831-f12/notes/F12/16831_lecture21_danielsm.pdf">Functional Gradient Descent - Part 1</a> and <a href="http://www.cs.cmu.edu/~16831-f14/notes/F10/16831_lecture24_varunnr/16831_lectureNov11.vramakri.pdf">Part 2</a>. Functional Gradient Descent was introduced in the NIPS publication <a href="https://papers.nips.cc/paper/1766-boosting-algorithms-as-gradient-descent.pdf">Boosting Algorithms as Gradient Descent</a> by Llew Mason, Jonathan Baxter, Peter Bartlett and Marcus Frean in the year 2000.</p> <p>We are all familiar with gradient descent for linear functions \(f(x) = w^Tx\).<br/> Once we define a loss \(L\), gradient descent does the following update steps (\(\eta\) is a parameter called the learning rate.): \[ w \rightarrow w - \eta \nabla L(w) \] where we move around in the space of weights. An example of a loss \(L\) is: \[ L(w) = \sum_{i=1}^n(y_i - w^Tx_i)^2 + \lambda\lVert w \rVert ^2 \] where the first term (the ‘L2’ term) measures how close \(f(x)\) is to \(y\), while the second term (the ‘regularization’ term) accounts for the ‘complexity’ of the learned function \(f\).</p> <p>Suppose we wanted to extend \(L\) to beyond linear functions \(f\). We want to minimize something like: \[ L(f) = \sum_{i=1}^n(y_i - f(x_i))^2 + \lambda\lVert f \rVert ^2 \] where \(\lVert f \rVert ^2\) again serves as a regularization term, and we have updates of the form: \[ f \rightarrow f - \eta \nabla L(f) \] where we move around in the space of functions, not weights!</p> <p>Turns out, this is completely possible! And goes by the name of ‘functional’ gradient descent, or gradient descent in function space.</p> <p>A question that one may have is: why do this in the first place? Every function can be parametrized, and we can do ‘ordinary’ gradient descent in the space of parameters, instead?</p> <p>The answer is: yes, you always can! In general, you can parametrize any function in a number of ways, each parametrization gives rise to different steps (and different functions at each step) in gradient descent.</p> <p>The advantage is that some loss functions that are non-convex when parametrized, can be convex in the function space: this means functional gradient descent can actually converge to global minima, when ‘ordinary’ gradient descent could possibly get stuck at local minima or saddle points.</p> <p>So, what does functional gradient descent mean?</p> <h3 id="functionals">Functionals</h3> <p>A functional is a function defined over functions, returning a real value.<br/> Examples:</p> <ul> <li>The evaluation functional \[ E_x(f) = f(x) \]</li> <li>The sum functional \[ S_{{x_1, \ldots, x_n}}(f) = \sum_{i = 1}^n f(x_i) dx \]</li> <li>The integration functional \[ I_{[a, b]}(f) = \int_a^b f(x) dx \]</li> </ul> <p>It follows that the composition of a function \(g: \mathbb{R} \to \mathbb{R}\) with a functional is also a functional. The loss function \(L(f)\) defined above is a functional!</p> <h3 id="reproducing-kernel-hilbert-space">Reproducing Kernel Hilbert Space</h3> <p>It turns out that it is especially convenient when functions come from a special set, called a reproducing kernel Hilbert space. A Hilbert space can be thought of as a vector space, where we have the notion of an inner product between two elements. (This is not the complete definition, but this is what we’ll need).</p> <hr/> <h4 id="review-kernels">Review: Kernels</h4> <p>A kernel \(K: X \times X \to \mathbb{R}\) is a function that generalizes dot products:</p> <ul> <li><em>Symmetry</em>: For any \(x_i, x_j \in X\): \[ K(x_i, x_j) = K(x_j, x_i). \]</li> <li><em>Positive Semi-Definiteness</em>: For any \(x_1, \ldots, x_n \in X\), the matrix \(K_M\) given by \[ K_{M_{ij}} = K(x_i, x_j) \] is positive semi-definite. Note that this implies \(K(x_i, x_j) \geq 0\) always.</li> </ul> <p>It turns out (Mercer’s condition) that these conditions are equivalent to \[ K(x_i, x_j) = \phi(x_i) \cdot \phi(x_j) \] where \(\phi\) is a function that is sometimes called the ‘feature map’. Thus, a kernel can be thought of as the dot product in some feature space (the range of \(\phi\)). Similar to the dot product then, the kernel measures similarity between two inputs.</p> <p>Examples of kernel functions include:</p> <ul> <li>Linear Kernel: \[ K(x_i, x_j) = x_i \cdot x_j \]</li> <li>Polynomial Kernel (of degree \(d\)): \[ K(x_i, x_j) = (x_i \cdot x_j + c)^d \] The presence of the \(c\) term allows coefficients of degree less than \(d\) to be accommodated too.</li> <li>RBF Kernel (of ‘width’ \(\sigma\)): \[ K(x_i, x_j) = \exp\left(-\frac{\lVert x_i - x_j \rVert^2}{2\sigma^2}\right) \]</li> </ul> <p>Try to derive what the associated feature map is, for each of these kernels!</p> <hr/> <p> </p> <p>We can now define a reproducing kernel Hilbert space or a ‘RKHS’.<br/> A <em>reproducing kernel Hilbert space</em>, obtained on fixing a kernel \(K\), is a space of functions where every function \(f\) is some linear combination of the kernel \(K\) evaluated at some ‘centers’ \(x_{Cf}\): \[ f(x) = \sum_{i = 1}^n \alpha_{f_i} K(x, x_{Cf_i}) \] or, ignoring the argument \(x\): \[ f = \sum_{i = 1}^n \alpha_{f_i} K(\cdot, x_{Cf_i}) \] For a kernel \(K\) will denote the associated reproducing kernel Hilbert space by \(H_K\).<br/> From the definition above, every \(f \in H_K\) is completely determined by the coefficients \(\alpha_f\) and the centers \(x_{Cf}\). Note that the number of centers (\(=\) dimension of \(\alpha_f\)) can vary between functions.</p> <p>We can now define the inner product (the ‘dot’ product) in \(H_K\) by: \[ f \cdot g = \sum_{i = 1}^{n_f} \sum_{j = 1}^{n_g} \alpha_{f_i} \alpha_{g_j} K(x_{Cf_i}, x_{Cg_j}) = \alpha_f K_{fg} \alpha_g \] where, \[ K_{{fg}_{ij}} = K(x_{Cf_i}, x_{Cg_j}). \] This inner product induces the norm \(\lVert \cdot \rVert\): \[ {\lVert f \rVert}^2 = f \cdot f = \alpha_f K_{ff} \alpha_f \geq 0. \] Why do we use the term reproducing? This is because we can ‘reproduce’ the value of \(f \in H_K\) at any \(x\) by taking the inner product of \(f\) with the ‘reproducing kernel’ function \(K(x, \cdot) \in H_K\): \[ f \cdot K(x, \cdot) = f(x). \] Verify this property!</p> <p>So, we’ve seen how to define the inner-product and norm \(\lVert f \rVert\) of any function \(f \in H_K\). But, in order to minimize via gradient descent, we need the definition of a derivative.</p> <h3 id="derivatives-of-functionals">Derivatives of Functionals</h3> <p>As reviewed in my previous post on <a href="/optimization/constrained/theory/2020/03/03/optimization-review.html">optimization theory</a>, one of the definitions of the derivative \(Df\) of a function \(f: \mathbb{R}^n \rightarrow \mathbb{R}\) is: \[ \lim_{\lVert h \rVert \rightarrow 0} \frac{\lVert{f(x + h) - (f(x) + Df(x) \cdot h)}\rVert}{\lVert{h}\rVert} = 0 \] where \(Df(x)\) is a size \(n\) row vector, with which the take the dot product of the direction \(h\) with.</p> <p>We may not be working in \(\mathbb{R}^n\) anymore, but this definition gives us that the derivative \(DE\) of a functional \(E\) on \(H_K\) must satisfy: \[ \lim_{\lVert h \rVert \rightarrow 0} \frac{\lVert{E(x + h) - (E(x) + DE(x) \cdot h)}\rVert}{\lVert{h}\rVert} = 0 \] where \(h\) and \(x\) are now functions in \(H_K\), instead of points. This means that \(DE(x)\) is a function, too! (Recall that addition of functions occurs point-wise.)</p> <hr/> <p><strong>Example 1:</strong> Let us take the example of the evaluation functional \(E_x(f) = f(x)\) and compute its derivative: \[ \begin{aligned} E(f + h) &amp;= (f + h)(x) \newline &amp;= f(x) + h(x) \newline &amp;= E(f) + h(x) \newline &amp;= E(f) + K(x, \cdot) \cdot h \newline \end{aligned} \] Thus, the derivative \(DE_x(f)\) is independent of \(f\), and is given by: \[ DE_x(f) = K(x, \cdot). \]</p> <p><strong>Example 2:</strong> Similarly, following the example of my reference material, the functional \(E(f) = {\lVert f \rVert}^2\) satisfies: \[ \begin{aligned} E(f + h) &amp;= {\lVert f + h \rVert}^2 \newline &amp;= {(f + h) \cdot (f + h)} \newline &amp;= {f \cdot f} + 2 {f \cdot h} + {h \cdot h} \newline &amp;= E(f) + 2 {f \cdot h} + {h \cdot h} \newline \end{aligned} \] Thus, the derivative \(DE(f)\) is defined as: \[ DE(f) = 2f. \] Note how similar this is to the derivative \(2x\) of the function \(x \to \lvert x \rvert^2\) on real numbers!</p> <hr/> <p> </p> <h4 id="the-chain-rule">The Chain Rule</h4> <p>Very fortunately, we also have the chain rule! As discussed before, if \(E\) is a functional and \(g: \mathbb{R} \to \mathbb{R}\) is differentiable, then \(g(E)\) is also a functional, with derivative: \[ D(g(E))(f) = g’(E(f)) \ DE(f). \]</p> <hr/> <p><strong>Example 3:</strong> Let us compute the derivative of the loss functional \(L(f) = \sum_{i=1}^n(y_i - f(x_i))^2 + \lambda\lVert f \rVert ^2\) with the chain rule: The individual terms in the first sum term is a composition of \[ g_i(x) = (y_i - x)^2 \text{ and } E_{x_i}. \] Thus, each of these terms has derivative: \[ \begin{aligned} D(g_i({x_i}))(f) &amp;= -2 (y_i - E_{x_i}(f)) \cdot DE_{x_i}(f) \newline &amp;= -2 (y_i - f(x_i)) \cdot K(x_i, \cdot). \end{aligned} \] The second term has derivative \(2\lambda f\), as derived above. Thus, the derivative \(DL(f)\) is given by: \[ DL(f) = \sum_{i = 1}^n -2 (y_i - f(x_i)) \cdot K(x_i, \cdot) + 2\lambda f. \]</p> <hr/> <p> </p> <p>There is one last point to note. When we take steps in ‘ordinary’ gradient descent, we move along the negative of the gradient vector because that is the direction along which the dot product with the gradient is minimum. No matter how this vector points! In some sense, we are not restricted to move in any direction. This is because our underlying domain is \(\mathbb{R}^n\).</p> <p>In ‘functional’ gradient descent, however, we are restricted to \(H_K\). How can we guarantee that when moving along \(DL(f)\), we do not stray out of \(H_K\)? One way to ensure that is by proving that we always have \(DL(f) \in H_K\). (This was true for our examples above! We have actually implicitly assumed this in our definition, too.) Then, closure of \(H_K\) under addition (and scalar multiplication) ensures that at every iteration, our current function \(f\) is in \(H_K\).</p> <p>This is what we will prove, in the next section.</p> <p>The <a href="https://papers.nips.cc/paper/1766-boosting-algorithms-as-gradient-descent.pdf">Boosting Algorithms as Gradient Descent</a> paper above, does not use reproducing kernel Hilbert spaces, and actually applies to more general sets of functions. This is why they mention the fact that moving along the gradient is not always possible. Instead, they move along the direction with the least dot product with the gradient, among all directions that keeps them within their domain of functions. With reproducing kernel Hilbert spaces, this is not a problem: we are, fortunately, not restricted to move along the negative of the gradient.</p> <h3 id="h_k-is-closed-under-the-derivative">\(H_K\) is Closed under the Derivative</h3> <p>If \(E\) is a functional on \(H_K\), and \(f \in H_K\), then we always have: \[ DE(f) \in H_K. \]</p> <p>Let us define the derivative \(DE^*(f)\) as a functional: \[ \lim_{\lVert h \rVert \rightarrow 0} \frac{\lVert{E(f + h) - (E(f) + DE^*(f)(h))}\rVert}{\lVert{h}\rVert} = 0 \] I differentiate between \(DE^*(f)\) (the functional) and \(DE(f)\) (the function). We want to show that, in fact: \[ DE^*(f)(h) = {\langle h, DE(f) \rangle}_K \]</p> <p>Note that \(DE^*(f)\) is a linear functional! Why? Using the definition above (and properties of the norm and limits):</p> <ul> <li>\(DE^*(f)(ch) = c \cdot DE^*(f)(h)\) where \(c \in \mathbb{R}\).</li> <li>\(DE^*(f)(h + g) = DE^*(f)(h) + DE^*(f)(g)\).</li> </ul> <p>This should not be surprising! We use \(DE^*(f)\) to give us the ‘best’ linear approximation around \(f\) along each direction \(h\).</p> <p>The <a href="https://en.wikipedia.org/wiki/Riesz_representation_theorem">Riesz Representation Theorem</a> then tells us that every linear functional \(L\) on a Hilbert space is actually of the form: \[ L = \langle \cdot, v \rangle \] for some \(v\) in the Hilbert space, where \(\langle \cdot, \cdot \rangle\) is the inner product in the Hilbert space.<br/> For an RKHS, the inner product is given by the kernel \(K\), so, \[ DE^*(f) = {\langle \cdot, DE(f) \rangle}_K \] for some \(DE(f) \in H_K\). This means, we can write: \[ DE^*(f)(h) = {\langle h, DE(f) \rangle}_K \] where \(DE(f) \in H_K\), which is what we had to show!</p> <h3 id="an-example">An Example</h3> <p>Consider the regression problem, where \(x_i,\) for \(i \in {1, \ldots, 20}\) are linearly spaced in \([-1, 1]\): \[ y_i = e^{-\left(\frac{x_i - 0.5}{0.5}\right)^2} + e^{-\left(\frac{x_i + 0.5}{0.5}\right)^2} + \frac{\mathcal{N}(0, 1)}{20} \]</p> <p>Although this is a simple enough problem that would be easily solved by ‘ordinary’ gradient descent, we will demonstrate how functional gradient descent works here.</p> <p>First, we need a loss function. We will use the L2 loss with regularization, \(L(f)\), defined above. We have already seen in Example 3, that the gradient of \(L(f)\) is: \[ DL(f) = \sum_{i = 1}^n -2 (y_i - f(x_i)) \cdot K(x_i, \cdot) + 2\lambda f. \] Let us define \(K\) as the RBF kernel with width \(0.5\). The presence of the Gaussian noise term above means the true hypothesis is not in \(H_K\), but we should get close!</p> <p>We initialize \(\alpha_{f_0}\) randomly, and set: \[ f_0 = \sum_{i = 1}^{20} \alpha_{f_0i} K(\cdot, x_i) \] and then start updating: \[ f_{t + 1} = f_t - \eta \cdot DL(f_t) \]</p> <p>This makes sense! But if we want to represent this in code, we would have to represent these functions in some way. One way is to maintain the coefficients \(\alpha_{f_t}\) and kernel centers \(x_{C{f_t}}\) at every iteration. We can simplify this by deciding to store only \(\alpha_{f_t}\) (allowing zeros) and implicitly use all \(x_i\) as the kernel centers. This is actually the same as doing gradient descent on \(\alpha_f\)! Other ways would be to add training samples one-by-one in an online manner, maintaining/recomputing the function values only at the training points. However, this causes a complication wherein the function is only defined at the training samples. To fix this, instead of updating by the gradient, we update using smooth functions that approximate the gradient: this is exactly gradient boosting!</p> <p>If we decide to represent our function implicitly by \(\alpha_f\) at each step, our updates are now: \[ \alpha_{f_{t + 1}} = 2 \eta (y - f_t(x)) + (1 - 2\lambda\eta) \alpha_{f_t} \] where \(y - f_t(x)\) is a vector with \((y - f_t(x))_i = y_i - f_t(x_i)\). Check this!</p> <p>If we implement all this, and plot the resulting learned hypothesis at each step of gradient descent:</p> <p style="text-align:center"><img src="/assets/images/functional_gradient_descent.gif" alt="Functional Gradient Descent Example" title="Functional Gradient Descent Example"/></p> <p>indicating that functional gradient descent converges pretty fast, for our example. The code for this example is available <a href="https://github.com/simple-complexities/simple-complexities.github.io/tree/master/code/functional_gradient_descent.py">here</a>.</p> <h3 id="conclusion">Conclusion</h3> <p>We have seen:</p> <ul> <li>Why functional gradient descent can be useful,</li> <li>What it means to do functional gradient descent, and,</li> <li>How we can do functional gradient descent, with an example.</li> </ul> <p>and that’s all I have for today.</p> <p>I’m also starting to introduce a commenting facility via GitHub Issues, in order to not clutter up this space here. Comment <a href="https://github.com/simple-complexities/simple-complexities.github.io/issues/3">here</a>!</p>]]></content><author><name></name></author><category term="blog"/><category term="RL,"/><category term="Programming"/><summary type="html"><![CDATA[Claim: This is a backup of this post!]]></summary></entry><entry><title type="html">How to plot performance figures in reinforcement learning papers</title><link href="https://qhe-ai.github.io/blog/2019/How_to_plot_figures_like_RL_papers/" rel="alternate" type="text/html" title="How to plot performance figures in reinforcement learning papers"/><published>2019-04-19T08:00:00+00:00</published><updated>2019-04-19T08:00:00+00:00</updated><id>https://qhe-ai.github.io/blog/2019/How_to_plot_figures_like_RL_papers</id><content type="html" xml:base="https://qhe-ai.github.io/blog/2019/How_to_plot_figures_like_RL_papers/"><![CDATA[<h1 id="如何绘制出强化学习论文里面的曲线图">如何绘制出强化学习论文里面的曲线图</h1> <p><img src="https://s2.ax1x.com/2019/04/10/ATk7lt.png" alt="论文里面好看的图"/></p> <p>paper里面含有精美的图能够增加文章中的概率, 那么强化学习论文里面那种精美的图到底是怎么画出来的呢?<br/> 答案是:使用seaborn绘制. 有人也提出来,可以使用origin绘制,但考虑到数据从python体系内转换到origin格式. 需要借助一些中介工具(比如excel), 这样子会增加难度.因此我们还是考虑使用seaborn来绘制.</p> <p>seaborn风格的图片如下:</p> <p><img src="https://s2.ax1x.com/2019/04/10/ATABB8.png" alt="seaborn"/></p> <h2 id="绘图需要用到的数据">绘图需要用到的数据</h2> <p>在RL里面,我们用来画图的数据一般包含:算法名字(用来分类), 平均reward回报, 随机种子(用来解决), 以及step次数.</p> <p>我们使用随机数据来生成这样的图片:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

time = np.linspace(0,200,201).reshape(-1,1)
Algo = ['PPO', 'DDPG', 'TRPO', 'DDPG-SG']


all = pd.DataFrame([])
for seed in range(10):
    for algo in Algo:
        data = pd.DataFrame(np.ones((201, 4)))
        data.columns = ['step', 'algo', 'avg_reward', 'seed']
        data['step'] = time
        data['algo'] = algo
        data['avg_reward'] = time + np.random.randn(201,1)*10
        data['seed'] = seed
        all = pd.concat([all, data], 0)

sns.lineplot(x='step', y='avg_reward', data=all, hue='algo')
plt.show()
</code></pre></div></div> <p>得到的效果:</p> <p><img src="https://s2.ax1x.com/2019/04/10/ATA6hj.png" alt="效果"/></p> <p>api详细信息请点<a href="https://seaborn.pydata.org/generated/seaborn.lineplot.html#seaborn.lineplot">此处</a></p> <h2 id="api细节">API细节</h2> <p>lineplot带有大量的参数</p> <pre><code class="language-angular2html">seaborn.lineplot(x=None, y=None, hue=None, size=None, 
style=None, data=None, palette=None, hue_order=None, 
hue_norm=None, sizes=None, size_order=None, size_norm=None, 
dashes=True, markers=None, style_order=None, units=None, 
estimator='mean', ci=95, n_boot=1000, sort=True, 
err_style='band', err_kws=None, legend='brief', ax=None, **kwargs)¶
</code></pre> <p>但是我们需要用到的参数就是那么几个</p> <ul> <li>x<br/> 输入的横坐标,注意横坐标的取值不一定是唯一的.在RL中,我们输入的横坐标一般是step.</li> <li>y 纵坐标, 我们的纵坐标一般是平均回报.</li> <li>hue<br/> 按照什么标准来分类画图.一般以算法来区分.</li> <li>ci <br/> 置信区间的大小, 设置为”sd”时候,就会画出标准差范围.一般取95. -error_style<br/> 误差带的类型,可在band和bars之间选择.一般选择band.</li> </ul>]]></content><author><name></name></author><category term="blog"/><category term="RL,"/><category term="Programming"/><summary type="html"><![CDATA[如何绘制出强化学习论文里面的曲线图]]></summary></entry><entry><title type="html">How to installation mpi4py in your ubuntu</title><link href="https://qhe-ai.github.io/blog/2019/How_to_install_mpi4py_in_your_ubuntu/" rel="alternate" type="text/html" title="How to installation mpi4py in your ubuntu"/><published>2019-03-18T08:00:00+00:00</published><updated>2019-03-18T08:00:00+00:00</updated><id>https://qhe-ai.github.io/blog/2019/How_to_install_mpi4py_in_your_ubuntu</id><content type="html" xml:base="https://qhe-ai.github.io/blog/2019/How_to_install_mpi4py_in_your_ubuntu/"><![CDATA[<h2 id="how-to-install-mpi4py-in-your-ubuntu-computer">How to install mpi4py in your ubuntu computer</h2> <p>首先要说明的是，直接使用pip　安装并不可取．</p> <h2 id="1-安装openmpi">1. 安装openmpi</h2> <ul> <li>1.1 下载 URL: http://www.open-mpi.org/software/ompi/v1.10/</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://www.open-mpi.org/software/ompi/v1.10/downloads/openmpi-1.10.2.tar.gz
tar xvzf openmpi-1.10.x.tar.gz
cd openmpi-xxx/
</code></pre></div></div> <ul> <li>1.2 编译安装</li> </ul> <p>首先编译:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./configure
</code></pre></div></div> <p>注意：不要使用</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash ./configure
</code></pre></div></div> <p>接下来安装:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo make all install
</code></pre></div></div> <p>注意:这里必须要使用sudo,否则会提示你权限不足</p> <ul> <li>1.3 添加环境变量</li> </ul> <p>进入~目录后</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo gedit .bashrc
</code></pre></div></div> <p>在最后一行添加上:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#mpi4py
export LD_LIBRARY_PATH+=:/usr/local/lib
</code></pre></div></div> <p>激活一下:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source /etc/profile
</code></pre></div></div> <ul> <li>1.4 进行测试</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd openmpi-1.10.2/examples
make
mpirun -np 4 hello_c
</code></pre></div></div> <p>当你的电脑上面显示:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, world, I am 0 of 4, (Open MPI v1.10.2, package: Open MPI mirror@agent Distribution, ident: 1.10.2, repo rev: v1.10.1-145-g799148f, Jan 21, 2016, 123)
Hello, world, I am 2 of 4, (Open MPI v1.10.2, package: Open MPI mirror@agent Distribution, ident: 1.10.2, repo rev: v1.10.1-145-g799148f, Jan 21, 2016, 123)
Hello, world, I am 3 of 4, (Open MPI v1.10.2, package: Open MPI mirror@agent Distribution, ident: 1.10.2, repo rev: v1.10.1-145-g799148f, Jan 21, 2016, 123)
Hello, world, I am 1 of 4, (Open MPI v1.10.2, package: Open MPI mirror@agent Distribution, ident: 1.10.2, repo rev: v1.10.1-145-g799148f, Jan 21, 2016, 123)

</code></pre></div></div> <p>这就说明openmpi安装好了.</p> <h2 id="2-安装mpi4py">2. 安装mpi4py</h2> <ul> <li>2.1 激活环境变量</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source ~/.bashrc
</code></pre></div></div> <ul> <li>2.2 安装mpi4py</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install mpi4py
</code></pre></div></div> <p>出现一下信息:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple
Collecting mpi4py
  Using cached https://pypi.tuna.tsinghua.edu.cn/packages/55/a2/c827b196070e161357b49287fa46d69f25641930fd5f854722319d431843/mpi4py-3.0.1.tar.gz
Building wheels for collected packages: mpi4py
  Building wheel for mpi4py (setup.py) ... done
  Stored in directory: /home/mirror/.cache/pip/wheels/73/ef/7a/e81433083a06d8735f0b50e1e388168b39b88444fd81fe5f27
Successfully built mpi4py
Installing collected packages: mpi4py
Successfully installed mpi4py-3.0.1
You are using pip version 19.0.2, however version 19.0.3 is available.
You should consider upgrading via the 'pip install --upgrade pip' command.

</code></pre></div></div> <p>说明已经成功安装上了</p> <ul> <li>2.3 检测是否成功安装</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import mpi4py.MPI as MPI
</code></pre></div></div> <p>之后再</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir(MPI)
</code></pre></div></div> <p>出现</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['AINT', 'ANY_SOURCE', 'ANY_TAG', 'APPNUM', 'Add_error_class', 'Add_error_code', 'Add_error_string', 'Aint_add', 'Aint_diff', 'Alloc_mem', 'Attach_buffer', 'BAND', 'BOOL', 'BOR', 'BOTTOM', 'BSEND_OVERHEAD', 'BXOR', 'BYTE', 'CART', 'CHAR', 'CHARACTER', 'COMBINER_CONTIGUOUS', 'COMBINER_DARRAY', 'COMBINER_DUP', 'COMBINER_F90_COMPLEX', 'COMBINER_F90_INTEGER', 'COMBINER_F90_REAL', 'COMBINER_HINDEXED', 'COMBINER_HINDEXED_BLOCK', 'COMBINER_HVECTOR', 'COMBINER_INDEXED', 'COMBINER_INDEXED_BLOCK', 'COMBINER_NAMED', 'COMBINER_RESIZED', 'COMBINER_STRUCT', 'COMBINER_SUBARRAY', 'COMBINER_VECTOR', 'COMM_NULL', 'COMM_SELF', 'COMM_TYPE_SHARED', 'COMM_WORLD', 'COMPLEX', 'COMPLEX16', 'COMPLEX32', 'COMPLEX4', 'COMPLEX8', 'CONGRUENT', 'COUNT', 'CXX_BOOL', 'CXX_DOUBLE_COMPLEX', 'CXX_FLOAT_COMPLEX', 'CXX_LONG_DOUBLE_COMPLEX', 'C_BOOL', 'C_COMPLEX', 'C_DOUBLE_COMPLEX', 'C_FLOAT_COMPLEX', 'C_LONG_DOUBLE_COMPLEX', 'Cartcomm', 'Close_port', 'Comm', 'Compute_dims', 'DATATYPE_NULL', 'DISPLACEMENT_CURRENT', 'DISP_CUR', 'DISTRIBUTE_BLOCK', 'DISTRIBUTE_CYCLIC', 'DISTRIBUTE_DFLT_DARG', 'DISTRIBUTE_NONE', 'DIST_GRAPH', 'DOUBLE', 'DOUBLE_COMPLEX', 'DOUBLE_INT', 'DOUBLE_PRECISION', 'Datatype', 'Detach_buffer', 'Distgraphcomm', 'ERRHANDLER_NULL', 'ERRORS_ARE_FATAL', 'ERRORS_RETURN', 'ERR_ACCESS', 'ERR_AMODE', 'ERR_ARG', 'ERR_ASSERT', 'ERR_BAD_FILE', 'ERR_BASE', 'ERR_BUFFER', 'ERR_COMM', 'ERR_CONVERSION', 'ERR_COUNT', 'ERR_DIMS', 'ERR_DISP', 'ERR_DUP_DATAREP', 'ERR_FILE', 'ERR_FILE_EXISTS', 'ERR_FILE_IN_USE', 'ERR_GROUP', 'ERR_INFO', 'ERR_INFO_KEY', 'ERR_INFO_NOKEY', 'ERR_INFO_VALUE', 'ERR_INTERN', 'ERR_IN_STATUS', 'ERR_IO', 'ERR_KEYVAL', 'ERR_LASTCODE', 'ERR_LOCKTYPE', 'ERR_NAME', 'ERR_NOT_SAME', 'ERR_NO_MEM', 'ERR_NO_SPACE', 'ERR_NO_SUCH_FILE', 'ERR_OP', 'ERR_OTHER', 'ERR_PENDING', 'ERR_PORT', 'ERR_QUOTA', 'ERR_RANK', 'ERR_READ_ONLY', 'ERR_REQUEST', 'ERR_RMA_ATTACH', 'ERR_RMA_CONFLICT', 'ERR_RMA_FLAVOR', 'ERR_RMA_RANGE', 'ERR_RMA_SHARED', 'ERR_RMA_SYNC', 'ERR_ROOT', 'ERR_SERVICE', 'ERR_SIZE', 'ERR_SPAWN', 'ERR_TAG', 'ERR_TOPOLOGY', 'ERR_TRUNCATE', 'ERR_TYPE', 'ERR_UNKNOWN', 'ERR_UNSUPPORTED_DATAREP', 'ERR_UNSUPPORTED_OPERATION', 'ERR_WIN', 'Errhandler', 'Exception', 'FILE_NULL', 'FLOAT', 'FLOAT_INT', 'F_BOOL', 'F_COMPLEX', 'F_DOUBLE', 'F_DOUBLE_COMPLEX', 'F_FLOAT', 'F_FLOAT_COMPLEX', 'F_INT', 'File', 'Finalize', 'Free_mem', 'GRAPH', 'GROUP_EMPTY', 'GROUP_NULL', 'Get_address', 'Get_error_class', 'Get_error_string', 'Get_library_version', 'Get_processor_name', 'Get_version', 'Graphcomm', 'Grequest', 'Group', 'HOST', 'IDENT', 'INFO_ENV', 'INFO_NULL', 'INT', 'INT16_T', 'INT32_T', 'INT64_T', 'INT8_T', 'INTEGER', 'INTEGER1', 'INTEGER16', 'INTEGER2', 'INTEGER4', 'INTEGER8', 'INT_INT', 'IN_PLACE', 'IO', 'Info', 'Init', 'Init_thread', 'Intercomm', 'Intracomm', 'Is_finalized', 'Is_initialized', 'Is_thread_main', 'KEYVAL_INVALID', 'LAND', 'LASTUSEDCODE', 'LB', 'LOCK_EXCLUSIVE', 'LOCK_SHARED', 'LOGICAL', 'LOGICAL1', 'LOGICAL2', 'LOGICAL4', 'LOGICAL8', 'LONG', 'LONG_DOUBLE', 'LONG_DOUBLE_INT', 'LONG_INT', 'LONG_LONG', 'LOR', 'LXOR', 'Lookup_name', 'MAX', 'MAXLOC', 'MAX_DATAREP_STRING', 'MAX_ERROR_STRING', 'MAX_INFO_KEY', 'MAX_INFO_VAL', 'MAX_LIBRARY_VERSION_STRING', 'MAX_OBJECT_NAME', 'MAX_PORT_NAME', 'MAX_PROCESSOR_NAME', 'MESSAGE_NO_PROC', 'MESSAGE_NULL', 'MIN', 'MINLOC', 'MODE_APPEND', 'MODE_CREATE', 'MODE_DELETE_ON_CLOSE', 'MODE_EXCL', 'MODE_NOCHECK', 'MODE_NOPRECEDE', 'MODE_NOPUT', 'MODE_NOSTORE', 'MODE_NOSUCCEED', 'MODE_RDONLY', 'MODE_RDWR', 'MODE_SEQUENTIAL', 'MODE_UNIQUE_OPEN', 'MODE_WRONLY', 'Message', 'NO_OP', 'OFFSET', 'OP_NULL', 'ORDER_C', 'ORDER_F', 'ORDER_FORTRAN', 'Op', 'Open_port', 'PACKED', 'PROC_NULL', 'PROD', 'Pcontrol', 'Prequest', 'Publish_name', 'Query_thread', 'REAL', 'REAL16', 'REAL2', 'REAL4', 'REAL8', 'REPLACE', 'REQUEST_NULL', 'ROOT', 'Register_datarep', 'Request', 'SEEK_CUR', 'SEEK_END', 'SEEK_SET', 'SHORT', 'SHORT_INT', 'SIGNED_CHAR', 'SIGNED_INT', 'SIGNED_LONG', 'SIGNED_LONG_LONG', 'SIGNED_SHORT', 'SIMILAR', 'SINT16_T', 'SINT32_T', 'SINT64_T', 'SINT8_T', 'SUBVERSION', 'SUCCESS', 'SUM', 'Status', 'TAG_UB', 'THREAD_FUNNELED', 'THREAD_MULTIPLE', 'THREAD_SERIALIZED', 'THREAD_SINGLE', 'TWOINT', 'TYPECLASS_COMPLEX', 'TYPECLASS_INTEGER', 'TYPECLASS_REAL', 'Topocomm', 'UB', 'UINT16_T', 'UINT32_T', 'UINT64_T', 'UINT8_T', 'UNDEFINED', 'UNEQUAL', 'UNIVERSE_SIZE', 'UNSIGNED', 'UNSIGNED_CHAR', 'UNSIGNED_INT', 'UNSIGNED_LONG', 'UNSIGNED_LONG_LONG', 'UNSIGNED_SHORT', 'UNWEIGHTED', 'Unpublish_name', 'VERSION', 'WCHAR', 'WEIGHTS_EMPTY', 'WIN_BASE', 'WIN_CREATE_FLAVOR', 'WIN_DISP_UNIT', 'WIN_FLAVOR', 'WIN_FLAVOR_ALLOCATE', 'WIN_FLAVOR_CREATE', 'WIN_FLAVOR_DYNAMIC', 'WIN_FLAVOR_SHARED', 'WIN_MODEL', 'WIN_NULL', 'WIN_SEPARATE', 'WIN_SIZE', 'WIN_UNIFIED', 'WTIME_IS_GLOBAL', 'Win', 'Wtick', 'Wtime', '__builtins__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__pyx_capi__', '__spec__', '_addressof', '_handleof', '_keyval_registry', '_lock_table', '_set_abort_status', '_sizeof', '_typecode', '_typedict', '_typedict_c', '_typedict_f', 'get_vendor', 'memory', 'pickle']

</code></pre></div></div> <p>这样子就说明安装成功了.</p>]]></content><author><name></name></author><category term="blog"/><category term="Programming"/><summary type="html"><![CDATA[How to install mpi4py in your ubuntu computer]]></summary></entry><entry><title type="html">Fix NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver</title><link href="https://qhe-ai.github.io/blog/2019/NVIDIA_SMI/" rel="alternate" type="text/html" title="Fix NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver"/><published>2019-03-13T08:00:00+00:00</published><updated>2019-03-13T08:00:00+00:00</updated><id>https://qhe-ai.github.io/blog/2019/NVIDIA_SMI</id><content type="html" xml:base="https://qhe-ai.github.io/blog/2019/NVIDIA_SMI/"><![CDATA[<p>#　NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running</p> <p>#＃ 问题描述：</p> <p>某次使用电脑之后, 打开电脑之后输入nvidia-smi 提示</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NVIDIA-SMI has failed because it couldn't communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running
</code></pre></div></div> <p>##　问题原因 这常常是因为用户在程序运行时强行关闭电脑，或者电脑断电而引起的．</p> <h2 id="解决方案">解决方案</h2> <p>大致就是重装一下驱动就可以</p> <ul> <li>１. 卸载原有驱动 <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get autoremove --purge nvidia*
</code></pre></div> </div> </li> <li> <ol> <li>增加ppa源</li> </ol> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo add-apt-repository ppa:graphics-drivers/ppa
sudo apt update
</code></pre></div></div> <ul> <li> <ol> <li>检测显卡版本及推荐的驱动</li> </ol> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu-drivers devices
</code></pre></div></div> <p>结果显示</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==
modalias : pci:v000010DEd00001B82sv00001458sd00003794bc03sc00i00
vendor   : NVIDIA Corporation
model    : GP104 [GeForce GTX 1070 Ti]
driver   : nvidia-driver-390 - distro non-free recommended
driver   : xserver-xorg-video-nouveau - distro free builtin

</code></pre></div></div> <p>说明我这里应该去安装390的驱动</p> <ul> <li> <ol> <li>重装驱动</li> </ol> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install nvidia-driver-390
</code></pre></div></div> <ul> <li> <ol> <li>重启 这是最重要的一步,如果你不重启,那么重装之后立即nvidia-smi是会发现现在还是没有办法使用的,重启之后就好了</li> </ol> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvidia-smi
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+-----------------------------------------------------------------------------+
| NVIDIA-SMI 390.116                Driver Version: 390.116                   |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|===============================+======================+======================|
|   0  GeForce GTX 107...  Off  | 00000000:01:00.0 Off |                  N/A |
|  0%   55C    P2    40W / 180W |   1046MiB /  8119MiB |     19%      Default |
+-------------------------------+----------------------+----------------------+

+-----------------------------------------------------------------------------+
| Processes:                                                       GPU Memory |
|  GPU       PID   Type   Process name                             Usage      |
|=============================================================================|
|    0      1401      G   /usr/lib/xorg/Xorg                           249MiB |
|    0      1573      G   /usr/bin/gnome-shell                         195MiB |
|    0      2509      C   /home/mirror/anaconda3/bin/python            533MiB |
|    0      2562      G   ...quest-channel-token=9028700102029312797    64MiB |
+-----------------------------------------------------------------------------+
</code></pre></div></div>]]></content><author><name></name></author><category term="blog"/><category term="Programming"/><summary type="html"><![CDATA[#　NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running]]></summary></entry></feed>